use anyhow::Result;
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ProofBn254 {
    Plonk(PlonkBn254Proof),
    Groth16(Groth16Bn254Proof),
}

/// A zero-knowledge proof generated by the PLONK protocol with a Base64 encoded gnark PLONK proof.
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct PlonkBn254Proof {
    pub public_inputs: [String; 2],
    pub encoded_proof: String,
    pub raw_proof: String,
    pub plonk_vkey_hash: [u8; 32],
}

impl PlonkBn254Proof {
    /// Returns the raw proof as bytes.
    pub fn raw_bytes(&self) -> Result<Vec<u8>> {
        hex::decode(&self.raw_proof).map_err(|_| anyhow::anyhow!("Invalid raw proof"))
    }

    /// Returns the raw proof as bytes, prepended with the first 4 bytes of the plonk vkey hash.
    pub fn raw_with_checksum(&self) -> Result<Vec<u8>> {
        Ok([self.plonk_vkey_hash[..4].to_vec(), hex::decode(&self.raw_proof)?].concat())
    }
}

/// A zero-knowledge proof generated by the Groth16 protocol with a Base64 encoded gnark Groth16
/// proof.
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct Groth16Bn254Proof {
    pub public_inputs: [String; 2],
    pub encoded_proof: String,
    pub raw_proof: String,
    pub groth16_vkey_hash: [u8; 32],
}

impl Groth16Bn254Proof {
    /// Returns the raw proof as bytes.
    pub fn raw_bytes(&self) -> Result<Vec<u8>> {
        hex::decode(&self.raw_proof).map_err(|_| anyhow::anyhow!("Invalid raw proof"))
    }

    /// Returns the raw proof as bytes, prepended with the first 4 bytes of the groth16 vkey hash.
    pub fn raw_with_checksum(&self) -> Result<Vec<u8>> {
        Ok([self.groth16_vkey_hash[..4].to_vec(), hex::decode(&self.raw_proof)?].concat())
    }
}
